# Instruction Set

| Mnemonic                 | Operands                                |                Stack<br>`{before} → {after}`                 | Description                                                  |
| ------------------------ | --------------------------------------- | :----------------------------------------------------------: | ------------------------------------------------------------ |
| NOP                      |                                         |                             `→`                              | No operation.                                                |
| IADD                     |                                         |                         `n1 n2 → n3`                         | Add `n1` and `n2`.                                           |
| ISUB                     |                                         |                         `n1 n2 → n3`                         | Subtract `n2` from `n1`.                                     |
| IMUL                     |                                         |                         `n1 n2 → n3`                         | Multiply `n1` and `n2`.                                      |
| IDIV                     |                                         |                         `n1 n2 → n3`                         | Divide `n1` by `n2`.                                         |
| IMOD                     |                                         |                         `n1 n2 → n3`                         | Divide `n1` by `n2` and push the remainder to the top of the stack. |
| INOT                     |                                         |                          `n1 → n2`                           | Logical negation of `n1`: if `n1 == 0`, `1` is pushed to the top of the stack; otherwise, `0` is pushed. |
| INEG                     |                                         |                          `n1 → n2`                           | Negate `n1`.                                                 |
| IEQ                      |                                         |                        `n1 n2 → flag`                        | Is `n1` equal to `n2`?                                       |
| INE                      |                                         |                        `n1 n2 → flag`                        | Is `n1` not equal to `n2`?                                   |
| IGT                      |                                         |                        `n1 n2 → flag`                        | Is `n1` greater than `n2`?                                   |
| IGE                      |                                         |                        `n1 n2 → flag`                        | Is `n1` greater than or equal to `n2`?                       |
| ILT                      |                                         |                        `n1 n2 → flag`                        | Is `n1` less than `n2`?                                      |
| ILE                      |                                         |                        `n1 n2 → flag`                        | Is `n1` less than or equal to `n2`?                          |
| FADD                     |                                         |                         `f1 f2 → f3`                         | Add `f1` and `f2`.                                           |
| FSUB                     |                                         |                         `f1 f2 → f3`                         | Subtract `f2` from `f1`.                                     |
| FMUL                     |                                         |                         `f1 f2 → f3`                         | Multiply `f1` and `f2`.                                      |
| FDIV                     |                                         |                         `f1 f2 → f3`                         | Divide `f1` by `f2`.                                         |
| FMOD                     |                                         |                         `f1 f2 → f3`                         | Divide `f1` by `f2` and push the remainder to the top of the stack. |
| FNEG                     |                                         |                          `f1 → f2`                           | Negate `f1`.                                                 |
| FEQ                      |                                         |                        `f1 f2 → flag`                        | Is `f1` equal to `f2`?                                       |
| FNE                      |                                         |                        `f1 f2 → flag`                        | Is `f1` not equal to `f2`?                                   |
| FGT                      |                                         |                        `f1 f2 → flag`                        | Is `f1` greater than `f2`?                                   |
| FGE                      |                                         |                        `f1 f2 → flag`                        | Is `f1` greater than or equal to `f2`?                       |
| FLT                      |                                         |                        `f1 f2 → flag`                        | Is `f1` less than `f2`?                                      |
| FLE                      |                                         |                        `f1 f2 → flag`                        | Is `f1` less than or equal to `f2`?                          |
| VADD                     |                                         |                `x1 y1 z1 x2 y2 z2 → x3 y3 z3`                | Add vectors `<< x1, y1, z1 >>` and `<< x2, y2, z2 >>`.       |
| VSUB                     |                                         |                `x1 y1 z1 x2 y2 z2 → x3 y3 z3`                | Subtract vector `<< x2, y2, z2 >>` from `<< x1, y1, z1 >>`.  |
| VMUL                     |                                         |                `x1 y1 z1 x2 y2 z2 → x3 y3 z3`                | Multiply vectors `<< x1, y1, z1 >>` and `<< x2, y2, z2 >>`, component-wise. |
| VDIV                     |                                         |                `x1 y1 z1 x2 y2 z2 → x3 y3 z3`                | Divide vector `<< x1, y1, z1 >>` by `<< x2, y2, z2 >>`, component-wise. |
| VNEG                     |                                         |                    `x1 y1 z1 → x2 y2 z2`                     | Negate each component of the vector `<< x1, y1, z1 >>`.      |
| IAND                     |                                         |                         `n1 n2 → n3`                         | Bitwise AND on `n1` and `n2`.                                |
| IOR                      |                                         |                         `n1 n2 → n3`                         | Bitwise OR on `n1` and `n2`.                                 |
| IXOR                     |                                         |                         `n1 n2 → n3`                         | Bitwise XOR on `n1` and `n2`.                                |
| I2F                      |                                         |                          `n1 → f1`                           | Convert a 32-bit signed integer to a floating-point number.  |
| F2I                      |                                         |                          `n1 → f1`                           | Convert a floating-point number to 32-bit signed integer.    |
| F2V                      |                                         |                       `f1 → f1 f1 f1`                        | Convert a floating-point number to a vector, by duplicating it twice. |
| PUSH_CONST_I             | *n1*                                    |                            `→ n1`                            | Push a 32-bit integer to the top of the stack.               |
| PUSH_CONST_F             | *f1*                                    |                            `→ f1`                            | Push a floating-point number to the top of the stack.        |
| DUP                      |                                         |                         `n1 → n1 n1`                         | Duplicate the value on the top of the stack.                 |
| DROP                     |                                         |                            `n1 →`                            | Remove the top value from the stack.                         |
| NATIVE                   | *argCount*, *returnCount*, *nativeHash* |              `arg1...argN → return1...returnN`               | Call the native command with hash `nativeHash` with the specifed number of arguments and return values. |
| ENTER                    | *argCount*, *frameSize*                 | `arg1...argN returnAddr → [arg1...argN returnAddr callerFrame local1...localN empty]` | Push the offset of the current frame `callerFrame` to the stack, advance the stack by `frameSize - argCount + 1` (to make space for locals, initialized to zero) and create a new frame starting at `arg1`.<br />For correct behaviour, `frameSize` should include `argCount`, plus 2 for `returnAddr` and `callerFrame`, and the number of locals, so `frameSize = argCount + 2 + localsCount`. |
| LEAVE                    | *argCount*, *returnCount*               | `[arg1...argN returnAddr callerFrame local1...localN empty] return1...returnN → return1...returnN` | Pop the return values, pop the the current frame, reinstate the frame at offset `callerFrame`, jump to `returnAddr` and push the return values. |
| LOAD                     |                                         |                         `addr1 → n1`                         | Dereference pointer `addr1` and push the value at that address to the top of the stack. |
| STORE                    |                                         |                         `n1 addr1 →`                         | Dereference pointer `addr1` and set the value at that address to `n1`. |
| STORE_REV                |                                         |                      `addr1 n1 → addr1`                      | Dereference pointer `addr1` and set the value at that address to `n1`, without removing `addr1` from the stack. |
| LOAD_N                   |                                         |                     `N addr1 → n1...nN`                      | Read `N` values from pointer `addr1` and push them to the top of the stack. |
| STORE_N                  |                                         |                     `n1...nN N addr1 →`                      | Write `N` values to pointer `addr1`.                         |
| ARRAY                    | *itemSize*                              |                  `index arrayAddr → addr1`                   | Push the address of the item at `index` in `arrayAddr` to the top of stack. |
| IOFFSET                  | *n1*                                    |                       `addr1 → addr2`                        | Offset `addr1` by `n1` (32-bit signed integer).            |
| LOCAL                    | *n1*                                    |                          `→ addr1`                           | Push the address of the frame offset `n1` to the top of stack. |
| STATIC                   | *n1*                                    |                          `→ addr1`                           | Push the address of the static offset `n1` to the top of stack. |
| GLOBAL                   | *n1*                                    |                          `→ addr1`                           | Push the address of the global `n1` to the top of stack.     |
| J                        | *label*                                 |                             `→`                              | Jump to `label`.                                             |
| JZ                       | *label*                                 |                            `n1 →`                            | Jump to `label` if `n1` equals `0`.                          |
| CALL                     | *label*                                 |                        `→ returnAddr`                        | Push the address of the next instruction to the top of stack and jump to `label`. |
| SWITCH                   | *value1:label1*, ..., *valueN:labelN*   |                            `n1 →`                            | If `n1` equals any `valueN`, jump to the associated `labelN`; otherwise, continue with the following instruction. |
| STRING                   |                                         |                         `n1 → str1`                          | Push the pointer to the string at offset `n1` to the top of the stack. |
| TEXT_LABEL_ASSIGN_STRING | *n1*                                    |                        `str1 addr1 →`                        | Copy `str1` into `addr1`, with maximum length `n1` including the null terminator. |
| TEXT_LABEL_ASSIGN_INT    | *n1*                                    |                         `n2 addr1 →`                         | Convert `n2` to a string and copy it into `addr1`, with maximum length `n1` including the null terminator. |
| TEXT_LABEL_APPEND_STRING | *n1*                                    |                        `str1 addr1 →`                        | Append `str1` to `addr1`, with maximum length `n1` including the null terminator. |
| TEXT_LABEL_APPEND_INT    | *n1*                                    |                         `n2 addr1 →`                         | Convert `n2` to a string and append it to `addr1`, with maximum length `n1` including the null terminator. |
| TEXT_LABEL_COPY          |                                         |         `src1...srcN srcCount destCount destAddr →`          | Copy `src` to `dest`, including the null terminator.         |
| CALLINDIRECT             |                                         |                   `funcAddr → returnAddr`                    | Push the address of the next instruction to the stack and jump to `funcAddr`. |