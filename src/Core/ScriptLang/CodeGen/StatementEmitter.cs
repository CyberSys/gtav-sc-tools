namespace ScTools.ScriptLang.CodeGen
{
    using System.Linq;

    using ScTools.ScriptLang.Ast;
    using ScTools.ScriptLang.Ast.Declarations;
    using ScTools.ScriptLang.Ast.Expressions;
    using ScTools.ScriptLang.Ast.Statements;
    using ScTools.ScriptLang.Semantics;

    public sealed class StatementEmitter : EmptyVisitor<Void, FuncDeclaration>
    {
        public CodeGenerator CG { get; }

        public StatementEmitter(CodeGenerator cg) => CG = cg;

        public override Void Visit(LabelDeclaration node, FuncDeclaration func)
        {
            // TODO: support local labels in assembler to prevent conflicts in assembly generated by the compiler
            CG.Sink.WriteLine(" {0}:", node.Name);
            return default;
        }

        public override Void Visit(VarDeclaration node, FuncDeclaration func) => default;
        public override Void Visit(AssignmentStatement node, FuncDeclaration func) => default;

        public override Void Visit(BreakStatement node, FuncDeclaration func)
        {
            CG.Sink.WriteLine("\tJ {0}", node.EnclosingStatement!.ExitLabel);
            return default;
        }

        public override Void Visit(ContinueStatement node, FuncDeclaration func)
        {
            CG.Sink.WriteLine("\tJ {0}", node.EnclosingLoop!.BeginLabel);
            return default;
        }

        public override Void Visit(GotoStatement node, FuncDeclaration func)
        {
            CG.Sink.WriteLine("\tJ {0}", node.Label!.Name);
            return default;
        }

        public override Void Visit(IfStatement node, FuncDeclaration func) => default;
        public override Void Visit(RepeatStatement node, FuncDeclaration func) => default;

        public override Void Visit(ReturnStatement node, FuncDeclaration func)
        {
            if (node.Expression is not null)
            {
                // TODO: push value of expression
            }
            CG.Sink.WriteLine("\tLEAVE {0}, {1}", func.Prototype.ParametersSize, func.Prototype.ReturnType.SizeOf);
            return default;
        }

        public override Void Visit(SwitchStatement node, FuncDeclaration func)
        {
            // TODO: push value of expression

            var operandsStr = string.Join(", ", node.Cases.OfType<ValueSwitchCase>()
                                                          .Select(c => $"{ExpressionEvaluator.EvalInt(c.Value, CG.Symbols)}:{c.Label}"));
            CG.Sink.WriteLine("\tSWITCH {0}", operandsStr);

            var defaultCase = node.Cases.OfType<DefaultSwitchCase>().SingleOrDefault();
            CG.Sink.WriteLine("\tJ {0}", defaultCase?.Label ?? node.ExitLabel);

            node.Cases.ForEach(c => c.Accept(this, func));
            CG.Sink.WriteLine(" {0}:", node.ExitLabel);
            return default;
        }

        public override Void Visit(ValueSwitchCase node, FuncDeclaration func) 
        {
            CG.Sink.WriteLine(" {0}:", node.Label);
            node.Body.ForEach(stmt => stmt.Accept(this, func));
            return default;
        }

        public override Void Visit(DefaultSwitchCase node, FuncDeclaration func)
        {
            CG.Sink.WriteLine(" {0}:", node.Label);
            node.Body.ForEach(stmt => stmt.Accept(this, func));
            return default;
        }

        public override Void Visit(WhileStatement node, FuncDeclaration func) => default;
        public override Void Visit(InvocationExpression node, FuncDeclaration func) => default;
    }
}
